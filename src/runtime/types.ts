/**
 * Pactwork Runtime Types
 *
 * Type definitions for runtime utilities that transform MSW handlers.
 * These types enable type-safe composition of handler transformations.
 */

import type { HttpHandler } from 'msw';

/**
 * Metadata for a single handler, enabling O(1) lookup by operationId.
 * Generated alongside handlers from OpenAPI spec.
 */
export interface HandlerMetadata {
  /** OpenAPI operationId */
  operationId: string;
  /** HTTP method (uppercase) */
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'HEAD' | 'OPTIONS';
  /** URL path pattern (e.g., '/api/users/:id') */
  path: string;
  /** Index in the handlers array for O(1) replacement */
  index: number;
}

/**
 * Map of operationId â†’ HandlerMetadata for all handlers.
 * Generated by pactwork generate command.
 */
export type HandlerMetaMap = Record<string, HandlerMetadata>;

/**
 * A scenario defines an alternative response for a handler.
 * Used with applyScenario() to simulate different API states.
 */
export interface Scenario<TData = unknown> {
  /** Human-readable name for the scenario */
  name: string;
  /** HTTP status code to return */
  status: number;
  /** Response body (will be JSON serialized) */
  data: TData;
  /** Optional response headers */
  headers?: Record<string, string>;
  /** Optional delay in milliseconds before responding */
  delay?: number;
}

/**
 * Map of scenario names to scenario definitions.
 * Typically organized by operationId.
 */
export type ScenarioMap<TData = unknown> = Record<string, Scenario<TData>>;

/**
 * Options for withLatency utility.
 */
export interface LatencyOptions {
  /** Fixed delay in milliseconds */
  delay?: number;
  /** Minimum delay for random range */
  min?: number;
  /** Maximum delay for random range */
  max?: number;
}

/**
 * Options for withRateLimit utility.
 */
export interface RateLimitOptions {
  /** Maximum requests allowed in the window */
  maxRequests: number;
  /** Time window in milliseconds */
  windowMs: number;
  /** Custom 429 response body */
  responseBody?: unknown;
  /** Custom response headers */
  headers?: Record<string, string>;
}

/**
 * A step in a sequence for withSequence utility.
 * Can be a status code or a full scenario.
 */
export type SequenceStep<TData = unknown> = number | Scenario<TData>;

/**
 * Options for withNetworkError utility.
 */
export interface NetworkErrorOptions {
  /** Type of network error to simulate */
  type: 'timeout' | 'abort' | 'network-error';
  /** Delay before error (for timeout simulation) */
  delay?: number;
  /** Custom error message */
  message?: string;
}

/**
 * Options for withSeed utility (deterministic data generation).
 */
export interface SeedOptions {
  /** Seed value for random number generator */
  seed: number | string;
  /** Whether to reset seed on each request */
  resetPerRequest?: boolean;
}

/**
 * A handler transformer function.
 * Takes handlers and returns transformed handlers.
 */
export type HandlerTransformer = (handlers: HttpHandler[]) => HttpHandler[];

/**
 * Result of applying a transformation.
 */
export interface TransformResult {
  /** The transformed handlers array */
  handlers: HttpHandler[];
  /** Operations that were modified */
  modifiedOperations: string[];
}

/**
 * State tracker for sequence utility.
 */
export interface SequenceState {
  /** Current index in the sequence */
  currentIndex: number;
  /** Total calls made */
  totalCalls: number;
}

/**
 * State tracker for rate limit utility.
 */
export interface RateLimitState {
  /** Timestamps of recent requests */
  requestTimestamps: number[];
  /** Number of requests that were rate limited */
  limitedCount: number;
}

/**
 * Combined state for all stateful utilities.
 * Useful for debugging and testing.
 */
export interface RuntimeState {
  sequences: Map<string, SequenceState>;
  rateLimits: Map<string, RateLimitState>;
}

/**
 * Factory function type for creating handlers.
 * Used internally for handler replacement.
 */
export type HandlerFactory = (
  method: string,
  path: string,
  resolver: (info: { request: Request }) => Promise<Response> | Response
) => HttpHandler;
