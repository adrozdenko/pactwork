/**
 * Scenario catalog generator for Pactwork Phase 2
 * Extracts all response codes from OpenAPI spec and generates type-safe scenario catalog
 */

import type { ParsedSpec, Endpoint } from '../parser/types.js'
import type {
  Scenario,
  OperationScenarios,
  ScenarioCatalog,
  ScenarioGeneratorOptions,
  ScenarioGeneratorResult,
} from './types.js'

export type {
  Scenario,
  OperationScenarios,
  ScenarioCatalog,
  ScenarioGeneratorOptions,
  ScenarioGeneratorResult,
} from './types.js'

/**
 * Generate a scenario catalog from a parsed OpenAPI spec
 */
export function generateScenarios(
  spec: ParsedSpec,
  options: ScenarioGeneratorOptions = {}
): ScenarioCatalog {
  const { includeSuccess = true, includeErrors = true } = options

  const operations: Record<string, OperationScenarios> = {}
  const statusCounts: Record<string, number> = {}
  let totalScenarios = 0

  for (const endpoint of spec.endpoints) {
    const operationId = getOperationId(endpoint)
    const scenarios: Record<string, Scenario> = {}

    for (const [statusCode, response] of Object.entries(endpoint.responses)) {
      // Filter by status type
      const isSuccess = statusCode.startsWith('2')
      const isError = statusCode.startsWith('4') || statusCode.startsWith('5')

      if (isSuccess && !includeSuccess) continue
      if (isError && !includeErrors) continue

      // Apply custom filters
      if (options.includeStatuses?.length) {
        if (!matchesStatusFilter(statusCode, options.includeStatuses)) continue
      }
      if (options.excludeStatuses?.length) {
        if (matchesStatusFilter(statusCode, options.excludeStatuses)) continue
      }

      const scenarioKey = getScenarioKey(statusCode)
      scenarios[scenarioKey] = {
        status: parseInt(statusCode, 10) || 0,
        description: response.description,
        schemaRef: extractSchemaRef(response),
        isSuccess,
      }

      // Track counts
      statusCounts[statusCode] = (statusCounts[statusCode] || 0) + 1
      totalScenarios++
    }

    if (Object.keys(scenarios).length > 0) {
      operations[operationId] = {
        operationId,
        method: endpoint.method,
        path: endpoint.path,
        scenarios,
      }
    }
  }

  return {
    pactwork: '1.0',
    generatedAt: new Date().toISOString(),
    spec: {
      title: spec.info.title,
      version: spec.info.version,
    },
    operations,
    summary: {
      totalOperations: Object.keys(operations).length,
      totalScenarios,
      byStatus: statusCounts,
    },
  }
}

/**
 * Generate TypeScript code for the scenario catalog
 */
export function generateScenariosCode(catalog: ScenarioCatalog): string {
  const lines: string[] = [
    '// Generated by Pactwork - DO NOT EDIT',
    `// Spec: ${catalog.spec.title} v${catalog.spec.version}`,
    `// Generated at: ${catalog.generatedAt}`,
    '',
    'export const scenarios = {',
  ]

  for (const [operationId, operation] of Object.entries(catalog.operations)) {
    lines.push(`  ${safeIdentifier(operationId)}: {`)

    for (const [scenarioKey, scenario] of Object.entries(operation.scenarios)) {
      const comment = scenario.description ? ` // ${scenario.description}` : ''
      lines.push(`    ${scenarioKey}: { status: ${scenario.status} },${comment}`)
    }

    lines.push('  },')
  }

  lines.push('} as const')
  lines.push('')
  lines.push('export type ScenarioKey = keyof typeof scenarios')
  lines.push('export type OperationId = keyof typeof scenarios')
  lines.push('')
  lines.push(`// Summary: ${catalog.summary.totalOperations} operations, ${catalog.summary.totalScenarios} scenarios`)
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate scenarios and code in one call
 */
export function generateScenariosWithCode(
  spec: ParsedSpec,
  options: ScenarioGeneratorOptions = {}
): ScenarioGeneratorResult {
  const catalog = generateScenarios(spec, options)
  const code = generateScenariosCode(catalog)
  return { catalog, code }
}

/**
 * Format scenarios for CLI display
 */
export function formatScenariosList(catalog: ScenarioCatalog): string {
  const lines: string[] = [
    `Scenarios for ${catalog.spec.title} v${catalog.spec.version}`,
    '',
    `Operations: ${catalog.summary.totalOperations}`,
    `Total Scenarios: ${catalog.summary.totalScenarios}`,
    '',
  ]

  for (const [operationId, operation] of Object.entries(catalog.operations)) {
    lines.push(`${operation.method.toUpperCase()} ${operation.path}`)
    lines.push(`  Operation: ${operationId}`)

    for (const [key, scenario] of Object.entries(operation.scenarios)) {
      const desc = scenario.description ? ` - ${scenario.description}` : ''
      const marker = scenario.isSuccess ? '✓' : '✗'
      lines.push(`    ${marker} ${key} (${scenario.status})${desc}`)
    }
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Get scenario coverage statistics
 */
export function getScenarioCoverage(catalog: ScenarioCatalog): {
  total: number
  success: number
  clientError: number
  serverError: number
  other: number
} {
  let success = 0
  let clientError = 0
  let serverError = 0
  let other = 0

  for (const operation of Object.values(catalog.operations)) {
    for (const scenario of Object.values(operation.scenarios)) {
      if (scenario.status >= 200 && scenario.status < 300) success++
      else if (scenario.status >= 400 && scenario.status < 500) clientError++
      else if (scenario.status >= 500 && scenario.status < 600) serverError++
      else other++
    }
  }

  return {
    total: catalog.summary.totalScenarios,
    success,
    clientError,
    serverError,
    other,
  }
}

// --- Helper functions ---

function getOperationId(endpoint: Endpoint): string {
  if (endpoint.operationId) {
    return endpoint.operationId
  }
  // Fallback: generate from method + path
  const pathPart = endpoint.path
    .replace(/^\//, '')
    .replace(/\{([^}]+)\}/g, 'By$1')
    .replace(/[/-]/g, '_')
  return `${endpoint.method}_${pathPart}`
}

function getScenarioKey(statusCode: string): string {
  const code = parseInt(statusCode, 10)

  // Handle default
  if (statusCode === 'default') return 'default'

  // Named scenarios for common status codes
  const namedStatuses: Record<number, string> = {
    200: 'success',
    201: 'created',
    204: 'noContent',
    400: 'badRequest',
    401: 'unauthorized',
    403: 'forbidden',
    404: 'notFound',
    409: 'conflict',
    422: 'unprocessable',
    429: 'rateLimited',
    500: 'serverError',
    502: 'badGateway',
    503: 'serviceUnavailable',
  }

  return namedStatuses[code] || `status${statusCode}`
}

function matchesStatusFilter(statusCode: string, filters: string[]): boolean {
  for (const filter of filters) {
    if (filter === statusCode) return true
    if (filter === '2xx' && statusCode.startsWith('2')) return true
    if (filter === '4xx' && statusCode.startsWith('4')) return true
    if (filter === '5xx' && statusCode.startsWith('5')) return true
  }
  return false
}

function extractSchemaRef(response: { content?: Record<string, { schema?: { $ref?: string } }> }): string | undefined {
  const jsonContent = response.content?.['application/json']
  return jsonContent?.schema?.$ref
}

function safeIdentifier(str: string): string {
  // If it's a valid JS identifier, return as-is
  if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(str)) {
    return str
  }
  // Otherwise, quote it
  return `'${str.replace(/'/g, "\\'")}'`
}
