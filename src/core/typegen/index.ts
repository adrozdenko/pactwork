import type { ParsedSpec, Schema, Endpoint } from '../parser/types.js'

export interface TypeGenOptions {
  /** Include request body types */
  includeRequestTypes?: boolean
  /** Include response types */
  includeResponseTypes?: boolean
  /** Include path parameter types */
  includePathParams?: boolean
  /** Include query parameter types */
  includeQueryParams?: boolean
  /** Export style: 'named' or 'default' */
  exportStyle?: 'named' | 'default'
}

export interface TypeGenResult {
  /** Generated TypeScript code */
  code: string
  /** List of generated type names */
  types: string[]
}

/**
 * Generate TypeScript types from a parsed OpenAPI spec
 */
export function generateTypes(spec: ParsedSpec, options: TypeGenOptions = {}): TypeGenResult {
  const {
    includeRequestTypes = true,
    includeResponseTypes = true,
    includePathParams = true,
    includeQueryParams = true,
  } = options

  const lines: string[] = []
  const generatedTypes: string[] = []

  lines.push('// Generated by Pactwork - DO NOT EDIT')
  lines.push(`// Source: OpenAPI ${spec.version}`)
  lines.push(`// Generated at: ${new Date().toISOString()}`)
  lines.push('')

  // Generate schema types
  for (const [name, schema] of Object.entries(spec.schemas)) {
    const typeName = pascalCase(name)
    const typeCode = schemaToType(schema, spec.schemas)
    lines.push(`export interface ${typeName} ${typeCode}`)
    lines.push('')
    generatedTypes.push(typeName)
  }

  // Generate endpoint-specific types
  for (const endpoint of spec.endpoints) {
    const baseName = getEndpointTypeName(endpoint)

    // Path parameters
    if (includePathParams) {
      const pathParams = endpoint.parameters.filter(p => p.in === 'path')
      if (pathParams.length > 0) {
        const typeName = `${baseName}PathParams`
        lines.push(`export interface ${typeName} {`)
        for (const param of pathParams) {
          const optional = param.required ? '' : '?'
          const paramType = param.schema ? schemaToTypeString(param.schema, spec.schemas) : 'string'
          lines.push(`  ${param.name}${optional}: ${paramType};`)
        }
        lines.push('}')
        lines.push('')
        generatedTypes.push(typeName)
      }
    }

    // Query parameters
    if (includeQueryParams) {
      const queryParams = endpoint.parameters.filter(p => p.in === 'query')
      if (queryParams.length > 0) {
        const typeName = `${baseName}QueryParams`
        lines.push(`export interface ${typeName} {`)
        for (const param of queryParams) {
          const optional = param.required ? '' : '?'
          const paramType = param.schema ? schemaToTypeString(param.schema, spec.schemas) : 'string'
          lines.push(`  ${param.name}${optional}: ${paramType};`)
        }
        lines.push('}')
        lines.push('')
        generatedTypes.push(typeName)
      }
    }

    // Request body
    if (includeRequestTypes && endpoint.requestBody) {
      const content = endpoint.requestBody?.content?.['application/json']
      if (content?.schema) {
        const typeName = `${baseName}Request`
        const typeCode = schemaToType(content.schema, spec.schemas)
        if (typeCode.startsWith('{')) {
          lines.push(`export interface ${typeName} ${typeCode}`)
        } else {
          lines.push(`export type ${typeName} = ${typeCode};`)
        }
        lines.push('')
        generatedTypes.push(typeName)
      }
    }

    // Response types
    if (includeResponseTypes) {
      const responseEntries = Object.entries(endpoint.responses)
      // Find the first 2xx status to use as the primary (no suffix) response
      const primaryStatus = responseEntries.find(([s]) => /^2\d{2}$/.test(s))?.[0]

      for (const [status, response] of responseEntries) {
        const content = response.content?.['application/json']
        if (content?.schema) {
          const statusName = status === primaryStatus ? '' : `_${status}`
          const typeName = `${baseName}Response${statusName}`
          const typeCode = schemaToType(content.schema, spec.schemas)
          if (typeCode.startsWith('{')) {
            lines.push(`export interface ${typeName} ${typeCode}`)
          } else {
            lines.push(`export type ${typeName} = ${typeCode};`)
          }
          lines.push('')
          generatedTypes.push(typeName)
        }
      }
    }
  }

  return {
    code: lines.join('\n'),
    types: generatedTypes,
  }
}

/**
 * Convert OpenAPI schema to TypeScript type definition
 */
function schemaToType(schema: Schema, schemas: Record<string, Schema>, indent = 0): string {
  const spaces = '  '.repeat(indent)

  if (schema.$ref) {
    const refName = schema.$ref.replace('#/components/schemas/', '')
    return pascalCase(refName)
  }

  if (schema.allOf) {
    const types = schema.allOf.map(s => schemaToType(s, schemas, indent))
    return types.join(' & ')
  }

  if (schema.oneOf || schema.anyOf) {
    const variants = schema.oneOf || schema.anyOf || []
    const types = variants.map(s => schemaToType(s, schemas, indent))
    return types.join(' | ')
  }

  if (schema.enum) {
    return schema.enum.map(v => JSON.stringify(v)).join(' | ')
  }

  switch (schema.type) {
    case 'string':
      return 'string'
    case 'integer':
    case 'number':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'null':
      return 'null'
    case 'array':
      if (schema.items) {
        const itemType = schemaToType(schema.items, schemas, indent)
        return `${itemType}[]`
      }
      return 'unknown[]'
    case 'object':
      if (schema.properties) {
        const props: string[] = []
        const required = schema.required || []
        for (const [propName, propSchema] of Object.entries(schema.properties)) {
          const optional = required.includes(propName) ? '' : '?'
          const propType = schemaToType(propSchema, schemas, indent + 1)
          props.push(`${spaces}  ${propName}${optional}: ${propType};`)
        }
        return `{\n${props.join('\n')}\n${spaces}}`
      }
      return 'Record<string, unknown>'
    default:
      return 'unknown'
  }
}

/**
 * Convert schema to inline type string (for simple types)
 */
function schemaToTypeString(schema: Schema, schemas: Record<string, Schema>): string {
  return schemaToType(schema, schemas, 0)
}

/**
 * Generate a type name from an endpoint
 */
function getEndpointTypeName(endpoint: Endpoint): string {
  if (endpoint.operationId) {
    return pascalCase(endpoint.operationId)
  }

  // Generate from method + path
  const pathParts = endpoint.path
    .split('/')
    .filter(p => p && !p.startsWith('{'))
    .map(p => pascalCase(p))

  return pascalCase(endpoint.method) + pathParts.join('')
}

/**
 * Convert string to PascalCase
 */
function pascalCase(str: string): string {
  const result = str
    .replace(/[-_./{}]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('')

  if (!result) return 'Unknown'
  // Prefix with _ if starts with a digit (invalid identifier)
  if (/^\d/.test(result)) return `_${result}`
  return result
}
