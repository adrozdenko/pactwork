import type { ParsedSpec, Schema, Endpoint } from '../parser/types.js'

export interface TypeGenOptions {
  /** Include request body types */
  includeRequestTypes?: boolean
  /** Include response types */
  includeResponseTypes?: boolean
  /** Include path parameter types */
  includePathParams?: boolean
  /** Include query parameter types */
  includeQueryParams?: boolean
}

export interface TypeGenResult {
  /** Generated TypeScript code */
  code: string
  /** List of generated type names */
  types: string[]
}

/** Context passed to type generation helpers */
interface TypeGenContext {
  lines: string[]
  generatedTypes: string[]
  schemas: Record<string, Schema>
}

/**
 * Generate TypeScript types from a parsed OpenAPI spec
 */
export function generateTypes(spec: ParsedSpec, options: TypeGenOptions = {}): TypeGenResult {
  const {
    includeRequestTypes = true,
    includeResponseTypes = true,
    includePathParams = true,
    includeQueryParams = true,
  } = options

  const ctx: TypeGenContext = {
    lines: [],
    generatedTypes: [],
    schemas: spec.schemas,
  }

  generateHeader(ctx, spec.version)
  generateSchemaTypes(ctx, spec.schemas)
  generateEndpointTypes(ctx, spec.endpoints, {
    includePathParams,
    includeQueryParams,
    includeRequestTypes,
    includeResponseTypes,
  })

  return {
    code: ctx.lines.join('\n'),
    types: ctx.generatedTypes,
  }
}

/** Generate file header comments */
function generateHeader(ctx: TypeGenContext, specVersion: string): void {
  ctx.lines.push('// Generated by Pactwork - DO NOT EDIT')
  ctx.lines.push(`// Source: OpenAPI ${specVersion}`)
  ctx.lines.push(`// Generated at: ${new Date().toISOString()}`)
  ctx.lines.push('')
}

/** Generate types for all schemas in the spec */
function generateSchemaTypes(ctx: TypeGenContext, schemas: Record<string, Schema>): void {
  for (const [name, schema] of Object.entries(schemas)) {
    const typeName = pascalCase(name)
    const typeCode = schemaToType(schema, ctx.schemas)
    // Use 'interface' only for object shapes, 'type' for everything else
    if (typeCode.startsWith('{')) {
      ctx.lines.push(`export interface ${typeName} ${typeCode}`)
    } else {
      ctx.lines.push(`export type ${typeName} = ${typeCode};`)
    }
    ctx.lines.push('')
    ctx.generatedTypes.push(typeName)
  }
}

/** Generate types for all endpoints */
function generateEndpointTypes(
  ctx: TypeGenContext,
  endpoints: Endpoint[],
  options: { includePathParams: boolean; includeQueryParams: boolean; includeRequestTypes: boolean; includeResponseTypes: boolean }
): void {
  for (const endpoint of endpoints) {
    const baseName = getEndpointTypeName(endpoint)

    if (options.includePathParams) {
      generateParamType(ctx, endpoint, baseName, 'path', 'PathParams')
    }
    if (options.includeQueryParams) {
      generateParamType(ctx, endpoint, baseName, 'query', 'QueryParams')
    }
    if (options.includeRequestTypes) {
      generateRequestType(ctx, endpoint, baseName)
    }
    if (options.includeResponseTypes) {
      generateResponseTypes(ctx, endpoint, baseName)
    }
  }
}

/** Generate path or query parameter types */
function generateParamType(
  ctx: TypeGenContext,
  endpoint: Endpoint,
  baseName: string,
  paramIn: 'path' | 'query',
  suffix: string
): void {
  const params = endpoint.parameters.filter(p => p.in === paramIn)
  if (params.length === 0) return

  const typeName = `${baseName}${suffix}`
  ctx.lines.push(`export interface ${typeName} {`)
  for (const param of params) {
    const optional = param.required ? '' : '?'
    const paramType = param.schema ? schemaToTypeString(param.schema, ctx.schemas) : 'string'
    const key = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(param.name) ? param.name : JSON.stringify(param.name)
    ctx.lines.push(`  ${key}${optional}: ${paramType};`)
  }
  ctx.lines.push('}')
  ctx.lines.push('')
  ctx.generatedTypes.push(typeName)
}

/** Generate request body type */
function generateRequestType(ctx: TypeGenContext, endpoint: Endpoint, baseName: string): void {
  if (!endpoint.requestBody) return

  const content = endpoint.requestBody.content?.['application/json']
  if (!content?.schema) return

  const typeName = `${baseName}Request`
  const typeCode = schemaToType(content.schema, ctx.schemas)
  if (typeCode.startsWith('{')) {
    ctx.lines.push(`export interface ${typeName} ${typeCode}`)
  } else {
    ctx.lines.push(`export type ${typeName} = ${typeCode};`)
  }
  ctx.lines.push('')
  ctx.generatedTypes.push(typeName)
}

/** Generate response types for all status codes */
function generateResponseTypes(ctx: TypeGenContext, endpoint: Endpoint, baseName: string): void {
  const responseEntries = Object.entries(endpoint.responses)
  const primaryStatus = responseEntries.find(([s]) => /^2\d{2}$/.test(s))?.[0]

  for (const [status, response] of responseEntries) {
    const content = response.content?.['application/json']
    if (!content?.schema) continue

    const statusName = status === primaryStatus ? '' : `_${status}`
    const typeName = `${baseName}Response${statusName}`
    const typeCode = schemaToType(content.schema, ctx.schemas)
    if (typeCode.startsWith('{')) {
      ctx.lines.push(`export interface ${typeName} ${typeCode}`)
    } else {
      ctx.lines.push(`export type ${typeName} = ${typeCode};`)
    }
    ctx.lines.push('')
    ctx.generatedTypes.push(typeName)
  }
}

/**
 * Convert a single OpenAPI type string to TypeScript type
 * Used for OpenAPI 3.1 array types (e.g., ["string", "null"])
 */
function typeToTS(type: string): string {
  switch (type) {
    case 'string':
      return 'string'
    case 'integer':
    case 'number':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'null':
      return 'null'
    case 'object':
      return 'Record<string, unknown>'
    case 'array':
      return 'unknown[]'
    default:
      return 'unknown'
  }
}

/**
 * Convert OpenAPI schema to TypeScript type definition
 */
function schemaToType(schema: Schema, schemas: Record<string, Schema>, indent = 0): string {
  const spaces = '  '.repeat(indent)

  if (schema.$ref) {
    const refName = schema.$ref.replace('#/components/schemas/', '')
    return pascalCase(refName)
  }

  if (schema.allOf) {
    const types = schema.allOf.map(s => schemaToType(s, schemas, indent))
    return types.join(' & ')
  }

  if (schema.oneOf || schema.anyOf) {
    const variants = schema.oneOf || schema.anyOf || []
    const types = variants.map(s => schemaToType(s, schemas, indent))
    return types.join(' | ')
  }

  if (schema.enum) {
    return schema.enum.map(v => JSON.stringify(v)).join(' | ')
  }

  // Handle OpenAPI 3.1 array types (e.g., ["string", "null"])
  if (Array.isArray(schema.type)) {
    const types = schema.type.map(t => typeToTS(t))
    return types.join(' | ')
  }

  switch (schema.type) {
    case 'string':
      return 'string'
    case 'integer':
    case 'number':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'null':
      return 'null'
    case 'array':
      if (schema.items) {
        const itemType = schemaToType(schema.items, schemas, indent)
        // Wrap in parentheses if itemType is a union or intersection
        if (itemType.includes(' | ') || itemType.includes(' & ')) {
          return `(${itemType})[]`
        }
        return `${itemType}[]`
      }
      return 'unknown[]'
    case 'object':
      if (schema.properties) {
        const props: string[] = []
        const required = schema.required || []
        for (const [propName, propSchema] of Object.entries(schema.properties)) {
          const optional = required.includes(propName) ? '' : '?'
          const propType = schemaToType(propSchema, schemas, indent + 1)
          props.push(`${spaces}  ${propName}${optional}: ${propType};`)
        }
        return `{\n${props.join('\n')}\n${spaces}}`
      }
      return 'Record<string, unknown>'
    default:
      return 'unknown'
  }
}

/**
 * Convert schema to inline type string (for simple types)
 */
function schemaToTypeString(schema: Schema, schemas: Record<string, Schema>): string {
  return schemaToType(schema, schemas, 0)
}

/**
 * Generate a type name from an endpoint
 */
function getEndpointTypeName(endpoint: Endpoint): string {
  if (endpoint.operationId) {
    return pascalCase(endpoint.operationId)
  }

  // Generate from method + path
  const pathParts = endpoint.path
    .split('/')
    .filter(p => p && !p.startsWith('{'))
    .map(p => pascalCase(p))

  return pascalCase(endpoint.method) + pathParts.join('')
}

/**
 * Convert string to PascalCase
 */
function pascalCase(str: string): string {
  const result = str
    .replace(/[-_./{}]/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('')

  if (!result) return 'Unknown'
  // Prefix with _ if starts with a digit (invalid identifier)
  if (/^\d/.test(result)) return `_${result}`
  return result
}
